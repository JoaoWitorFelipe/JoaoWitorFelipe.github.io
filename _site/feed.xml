<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2024-04-02T22:22:03+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Dumper</title><subtitle>Aqui eu vou falar sobre o que vivencio no trabalho ou sobre discuss√µes com meus amigos, pretendo apenas  falar sobre tecnologias. Pretendo explicar conte√∫dos de forma mais educativa poss√≠vel at√© mesmo para rec√©m programadores ou at√© mesmo &quot;n√£o-programadores&quot; possam entender.</subtitle><entry><title type="html">Promessas - Promise All</title><link href="http://0.0.0.0:4000/jekyll/update/2024/03/17/promessas-promise.all.html" rel="alternate" type="text/html" title="Promessas - Promise All" /><published>2024-03-17T18:30:00+00:00</published><updated>2024-03-17T18:30:00+00:00</updated><id>http://0.0.0.0:4000/jekyll/update/2024/03/17/promessas-promise.all</id><content type="html" xml:base="http://0.0.0.0:4000/jekyll/update/2024/03/17/promessas-promise.all.html"><![CDATA[<p>Esse √© o meu primeiro post, espero que gostem e consigam aprender algo com meu jeito de escrever/expressar üòÑ.</p>

<p>Uns dias atr√°s a partir da data que eu comecei a escrever isso aqui, eu recebi uma tarefa para adicionar um novo filtro no <em>front-end</em> e 
consequentemente tamb√©m teria que aplicar um <em>‚Äúwhere‚Äù</em> no banco de dados para esse novo filtro. Quando me deparo com o seguinte c√≥digo no <em>front-end</em> (usamos Vue.js):</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getCompanies</span><span class="p">();</span>
<span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getSavedFilters</span><span class="p">();</span>
<span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getBanks</span><span class="p">();</span>
<span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getPaymentMethods</span><span class="p">();</span>
<span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getCustomers</span><span class="p">();</span>
<span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getSuppliers</span><span class="p">();</span></code></pre></figure>

<p><em>(meramente ilustrativo, tem uma coisa chamada confidencialidade que a gente assina nos contratos com as empresas, baboseira isso ai rs)</em></p>

<p>A princ√≠pio inofensivo, n√£o √© mesmo? Por√©m eu estava usando um banco de dados de teste (remoto, e n√£o t√£o perfom√°tico quanto de produ√ß√£o) e a tela estava demorando uns segundos para carregar.</p>

<p>Para termos uma visualiza√ß√£o melhor desse c√≥digo na pr√°tica, vamos olhar o diagrama abaixo:</p>

<script src="../../../../../../assets/mermaid.js"></script>
<div class="mermaid">
sequenceDiagram
    front-end-&gt;&gt;back-end: getCompanies() 
    back-end--&gt;&gt;front-end: getCompanies() 
    front-end-&gt;&gt;back-end: getSavedFilters() 
    back-end--&gt;&gt;front-end: getSavedFilters() 
    front-end-&gt;&gt;back-end: getBanks() 
    back-end--&gt;&gt;front-end: getBanks() 
    front-end-&gt;&gt;back-end: ... 
    back-end--&gt;&gt;front-end: ... 
</div>

<p>Pensando que cada fun√ß√£o pode levar 1 segundo de ida e volta, levar√≠amos 6 segundos no total para carregar uma tela com filtros, ent√£o pensei, ‚Äúok, esses <em>‚Äúawaits‚Äù</em> sequenciais v√£o esperar executar um de cada vez e por isso est√° demorando o <em>loading</em>‚Äù, logo pensei na fun√ß√£o do ‚Äújavascripto‚Äù
chamada <code class="language-plaintext highlighter-rouge">Promise.all</code> para poder paralelizar e otimizar o tempo, ent√£o o c√≥digo ficou isso aqui:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="k">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span>
  <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getCompanies</span><span class="p">();</span>
  <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getSavedFilters</span><span class="p">();</span>
  <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getBanks</span><span class="p">();</span>
  <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getPaymentMethods</span><span class="p">();</span>
  <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getCustomers</span><span class="p">();</span>
  <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getSuppliers</span><span class="p">();</span>
<span class="p">])</span></code></pre></figure>

<p>Show de bola! Coisa de 2min, com uma boa otimiza√ß√£o, e de fato, o <em>loading</em> que carregava esses dados abaixou o tempo de segundos para milisegundos, logo pensei ‚Äúem produ√ß√£o esse <em>loading</em> vai ficar inv√≠sivel praticamente‚Äù. Mas, adivinha? A vida n√£o √© um morango üò†.</p>

<p>Ap√≥s carregar a tela com os dados, comecei a notar alguns comportamentos estranhos/errados nos filtros, era para preencher automaticamente alguns campos com valores que foram usados anteriormente.
Por√©m n√£o carregaram, ent√£o fui revisar o que cada fun√ß√£o fazia e √© aqui que foi o motivo para escrever esse <em>post</em>, apresentar solu√ß√µes e seus poss√≠veis problemas juntos.</p>

<p>Ent√£o, o que aconteceu aqui? Quando usamos qualquer solu√ß√£o que envolve paralelismo, temos que pensar que podem haver problemas de concorr√™ncia. O que isso quer dizer? Significa que tinha uma fun√ß√£o que deveria executar primeiro, por√©m o <code class="language-plaintext highlighter-rouge">Promise.all</code> n√£o est√° nem ai com suas prioridades, ele vai executar tudo junto e resolver cada um no seu tempo, ent√£o o c√≥digo necessitou fazer a seguinte modifica√ß√£o:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getCompanies</span><span class="p">();</span>
<span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getSavedFilters</span><span class="p">();</span>
<span class="k">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span>
  <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getBanks</span><span class="p">();</span>
  <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getPaymentMethods</span><span class="p">();</span>
  <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getCustomers</span><span class="p">();</span>
  <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getSuppliers</span><span class="p">();</span>
<span class="p">])</span></code></pre></figure>

<p>Eu preciso esperar que as fun√ß√µes <code class="language-plaintext highlighter-rouge">getCompanies()</code> e <code class="language-plaintext highlighter-rouge">getSavedFilters()</code> finalizarem primeiro, porque as outras fun√ß√µes (dentro da <code class="language-plaintext highlighter-rouge">Promise.all</code>) iriam depender das mudan√ßas 
de alguns estados (famoso <em>side-effects</em> mas fica para outro <em>post</em> quando tiver vontade) que essas fun√ß√µes de fora executam.</p>

<p>Agora n√≥s temos o seguinte diagrama que representa nosso c√≥digo, em ordem de execu√ß√£o:</p>

<script src="../../../../../../assets/mermaid.js"></script>
<div class="mermaid">
graph TD;
    getCompanies(getCompanies)--&gt;|await|getSavedFilters(getSavedFilters)
    getSavedFilters--&gt;|await|promisseAll
    promisseAll--&gt;back-end1(getBanks);
    promisseAll--&gt;back-end2(getPaymentsMethods);
    promisseAll--&gt;back-end3(getCustomers);
    promisseAll--&gt;back-end4(getSuppliers);
</div>

<p>Ou seja, a fun√ß√£o <code class="language-plaintext highlighter-rouge">Promise.all</code> ir√° invocar as 4 fun√ß√µes ao mesmo tempo para processar, n√£o conseguimos paralelizar todas as fun√ß√µes mas ainda assim conseguimos manter uma boa otimiza√ß√£o no tempo de execu√ß√£o do c√≥digo, entretanto foi necess√°rio validar se havia algum problema de concorr√™ncia (eu tinha consci√™ncia disso) para evitar novos <em>bugs</em> em produ√ß√£o. 
Al√©m do mais, paralelizar fun√ß√µes dependendo do que est√£o executando, podem consumir muito processamento (mas isso fica em outro <em>post</em> quando tiver vontade tamb√©m rs).</p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Esse √© o meu primeiro post, espero que gostem e consigam aprender algo com meu jeito de escrever/expressar üòÑ.]]></summary></entry></feed>