---
layout: post
title:  "Desenho de arquitetura para uma API"
date:   2024-06-24 18:30:00 +0000
categories: jekyll update
---

Quero contribuir um pouco sobre desenho de arquitetura e sugerir ferramentas que conheço ou vou descobrindo enquanto escrevo isso que vão ajudar, até então eu estou estudando mais sobre o assunto mas decidi iniciar uma postagem para poder me auxiliar nos estudos.
Vou colocar um desafio para então construir um desenho de arquitetura. O desafio vai ser uma API de transações de dinheiro, nós teremos as seguintes opções:
 - Ter uma conta com o saldo zerado (essa conta pode ser compartilhada com mais de uma pessoa);
 - Depositar dinheiro;
 - Resgatar dinheiro;
 - Transferir dinheiro para outra conta.

Problemas encontrados:
 - Não permitir saldo negativo (vamos supor que 2 pessoas tentem fazer operações na conta e falte dinheiro pra um ou pra outro);
 - Segurança;
 - Escalabilidade;
 - Monitoramento;

<img src="/assets/2024-06-24-api-arch.markdown/initial_arch.png" alt="drawing" width="100%" />

Muitas vezes essa é a nossa aplicação que construímos, apenas um cliente que pode ser outra aplicação ou Postman/Insomnia requisitando nossa API e que bate no banco de dados. E a grosso modo é isso mas vamos começar a levantar alguns problemas, escalabilidade, de acordo com a nossa primeira imagem, a nossa API aguenta apenas 100 requisições, como podemos aumentar isso? 

Bom, podemos subir uma segunda aplicação (ou várias outras) e balancear as requisições ([para mais detalhes](https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/)) dos clientes com NGINX para usar a API 1 ou 2. Se a API 1 aguenta 100 requisições por vez, agora seremos capazes de suportar até 200 requisições:
<img src="/assets/2024-06-24-api-arch.markdown/load_balancer.png" alt="drawing" width="100%" />

Agora que conseguimos ter mais acessos simultâneos, vamos supor que temos uma conta com 100 reais e 2 usuários querem sacar os 100 reais, como podemos resolver?
Temos algumas opções para essa situação:
 - Lock otimista, versionar a visualização dos dados (ainda necessita do lock pessimista mas dá para evitar).
 - Lock pessimista, ao tentar mexer no banco de dados, nós bloqueamos a conta que contém o saldo de 100 reais e apenas uma operação pode executar por vez;

Vamos começar com o lock pessimista que talvez seja a solução mais comum, rápida e fácil. Um lock pessimista é quando precisamos travar (lock) algum prcesso e não permitir que nenhum outro processo possa interferir no que já está rodando. Por exemplo, os bancos de dados possuem uma funcionalidade chamada `select ... for update` ([para mais detalhes](https://dev.mysql.com/doc/refman/8.4/en/innodb-locking-reads.html)). Essa funcionalidade trava as linhas que foram selecionadas para realizar o `update` no banco de dados, qualquer outro cliente que tentar acessar essas linhas receberá um erro até a transação ser finalizada. Seguindo no gráfico abaixo teríamos um fluxo assim, sendo que o cliente com ID 1 conseguiu acessar o banco de dados primeiro:
<img src="/assets/2024-06-24-api-arch.markdown/pessimistic_lock.png" alt="drawing" width="100%" />

O lock pessimista resolve o maior problema disso porém é custoso, é pesado fazer isso e deixa a requisição lenta, para aprimorar isso, podemos adicionar um lock otimista na frente utilizando versionamento dos dados, vamos pensar no seguinte fluxo:

<img src="/assets/2024-06-24-api-arch.markdown/optimistic_lock.png" alt="drawing" width="100%" />

Ou seja, agora estamos versionando os dados antes deles seram alterados, como podemos ver, temos uma nova coluna chamada versão, para que ela serve? Vamos analisar o fluxo, o cliente com ID 1 consulta os dados e viu que o saldo é 100 reais na versão 1, quando ele tentou sacar, primeiro adicionamos uma validação para confirmar que a versão dos dados que ele está olhando é a mesma que está armazenado e está! Quer dizer que ele pode sacar esse dinheiro, entretanto, logo em seguida, o cliente com o ID 2 foi tentar sacar 100 reais também porém os dados que ele está vendo estão na versão 1 ao invés da versão 2 que já está com o valor zerado. Isso quer dizer que os dados que o cliente 2 está desatualizado e que devemos notificar ele com uma mensagem e com o novo saldo, para que o cliente com ID 2 possa tomar outra decisão.

Só que agora vêm uma pergunta, pra que fazer tantas validações? Dessa forma, nós conseguimos previnir que locks pessimistas sejam executados o tempo inteiro, tendo uma resposta mais rápida para o cliente. Mesmo com essa solução, ainda será necessário do lock pessimista como um último recurso de proteção mas conseguimos evitar em certas situações.

E é claro que, se a gente olhar com mais carinho ainda há brechas para que o saldo fique negativo, mas queria mostrar algumas soluções e direcionamento de como devemos nos preocupar com os sistemas que desenvolvemos.